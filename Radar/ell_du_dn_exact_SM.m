function  [dudn_ex,du_dxi,th] = ell_du_dn_exact_SM(a,b,kappa,th,alphaInc)% This program solves the equation % alphaInc =alphaInc*pi/180;%alphaInc1 =pi - alphaInc*pi/180;% Define the angular mesh %%th = 0:2:358;%th=th*pi/180;nbElemT=max(size(th)); dudn_ex = zeros(nbElemT,1);dudn_ex=ffp_ell_m(a,b,kappa,abs(alphaInc),th,nbElemT); % 1.0050378%dudn_ex=ffp_ell_m(a,b,kappa,abs(alphaInc),th,nbElemT);xi=(a/b)/sqrt((a/b)^2-1); %cosh(u)d=sqrt(a^2-b^2);u_in=exp(-sqrt(-1)*kappa*( cos(alphaInc)*a*cos(th) + sin(alphaInc)*b*sin(th) ));du_dxi=-(b/a)*(sqrt(-1)*kappa*a-0.5)*u_in;% figure(1)% clf% sig1=norm(real(dudn_ex));% sig2=norm(real(du_dxi));% s1=sprintf('real du/dn EXE  SOL');% s2=sprintf('real du/dn BGT1 SOL');% s12=[s1;s2];% plot(th*180/pi,real(dudn_ex)/sig1,'r+');% hold on% plot(th*180/pi,real(du_dxi)/sig2, 'bo');% legend(s12)% size(real(-du_dxi))% size(real(dudn_ex))% disp([' mean sqrt error for real part:',num2str( sqrt((1/360)* norm( abs(real(dudn_ex'))/sig1 - abs(real(-du_dxi))/sig2 )))]);% figure(2)% clf% sig1=norm(imag(dudn_ex));% sig2=norm(imag(du_dxi));% disp([' mean sqrt error for imag part:',num2str( sqrt((1/360)* norm( abs(imag(dudn_ex'))/sig1 - abs(imag(-du_dxi))/sig2 )))]);% s1=sprintf('imag du/dn EXE  SOL');% s2=sprintf('imag du/dn BGT1 SOL');% s12=[s1;s2];% plot(th*180/pi,imag(-dudn_ex)/sig1,'r+');% hold on% plot(th*180/pi,imag(du_dxi)/sig2, 'bo');% legend(s12)% % disp(['-&gt;Relative error for FFP:',num2str( norm(abs(ffpPU)/sig2 - abs(ffpEx)/sig1)/ ...%      norm(abs(ffpEx)/sig1))]);% % % % disp(' ');%====================================================================function [u]=ffp_ell_m(a,b,kappa,alphaInc,eta,nbElemT)%xi=[1.00005,1.0050378,1.0206207,1.1547005];%      |eta|<= 1  1 <= psi < infinity   psi=cosh(u)  etafg=[];u =zeros(nbElemT,1);u1 =zeros(nbElemT,1);u2 =zeros(nbElemT,1);cem1=zeros(nbElemT,1);sem1=zeros(nbElemT,1);%cem1=zeros(180,1);i=0;%a%bd=sqrt(a^2 - b^2); %/*semi-focal distance*/xi0=(a/b)/sqrt( (a/b)^2 -1 );xi=(a/b)/sqrt( (a/b)^2 -1 );xi=log(xi+sqrt(xi^2 - 1));q=0.25*(d*kappa)^2;% d1=sqrt(a1^2 - b1^2); %/*semi-focal distance*/% xi1=(a1/b1)/sqrt( (a1/b1)^2 -1 );% xi1=log(xi1+sqrt(xi1^2 - 1));% q1=0.25*(d1*kappa)^2s=4*q;nnn=1;norm=1;max_=300;f=zeros(1,max_+1);for m=0:6    %mnorm1=1;norm2=1;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[cem1_0,norm,fg]=mathieuangular(0,0,m,s,alphaInc,f,norm,1,fg);if(m > 0)[sem1_0,norm,fg]=mathieuangular(1,0,m,s,alphaInc,f,norm,1,fg);elsesem1_0=0;end;[cem1,norm,fg]=mathieuangular(0,0,m,s,eta,f,norm,1,fg);  % der=1 second argnorm1=norm;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if(m > 0)[sem1,norm,fg]=mathieuangular(1,0,m,s,eta,f,norm,1,fg);  % der=1 second argnorm2=norm;end;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%re1=MCJ(m,xi,q);re3 = MCH(m,xi,q);dre3_dxi =mathieuradial(0,1,1,m,4*q,xi,200,1)*(DMCH(m,xi,q)/DMCJ(m,xi,q));%dre3_dxi =DMCH(m,xi,q);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if(m > 0)ro1=MSJ(m,xi,q);elsero1=0;end;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%if(m > 0)    ro3 = MSH(m,xi,q);    dro3_dxi =mathieuradial(1,1,1,m,4*q,xi,200,1)*(DMSH(m,xi,q)/DMSJ(m,xi,q));    %dro3_dxi=DMSH(m,xi,q);else    ro3=1;    dro3_dxi=1;end;u1=cem1*re1*dre3_dxi*cem1_0/(re3*norm1);if(m>0)    u2=sem1*ro1*dro3_dxi*sem1_0/(ro3*norm2);% else%     u2=u2';end;%u = u + (sqrt(-1)^m)*( u1 + u2 )';u = u(:) + ((-1i)^m)*( u1(:) + u2(:) );endu=-sqrt(8*pi)*u;%h_xi=zeros(nbElemT+1,1);% for i=1:nbElemT+1% h_xi(i)=xi0^2 - 1;%end;%h_xi=(1)./d*sqrt(h_xi' + sin(eta).*sin(eta));% h_xi=(1)./sqrt(a^2*sin(eta).*sin(eta) + b^2*cos(eta).*cos(eta));% h_xi% u=u.*h_xi';function [mathieuangularResult,norm,fg]=mathieuangular(parity,der,n,s,x,f,norm,choice,varargin)%%  copyright by Danilo Erricolo%  University of Illinois at Chicago%  Oct 1, 2002%     ========================================================%     Purpose%     Compute the Angular Mathieu function Se, So%     parity: 0  Even, such as Se%     INPUT%             1  Odd, such as So%     der     0 No derivatives required%             1 Derivatives are required%     n       order of the Mathieu function%     s       parameter of the Mathieu function, according to the notation of Blanch%     x       argument of the Mathieu function%  OUTPUT%     F       array of expansion coefficients%  Norm    normalization coefficient%  choice  normalization requested: 1(Stratton),(2) Ince,(3) Neutral%     ========================================================%%%use constants;kf=[];q=[];csf=[];csd=[];fg=[]; q=0;%   variables required by the subroutines called by this function  kf=0;  csf=0;  csd=0;%The routines of Zhang and Jin use the parameter q=s/4q=s./4;%q,x,n,choice%Determine case function(KF) and compute the appropriate normalization coefficientif(parity==0) ;kf=1;else;kf=2;end;if((parity==1) &(n==0)) ;mathieuangularResult=0.0;  %zeronorm=1.0;%one;fprintf('warning: angular odd functions are zero for m=0');%!!'else;[kf,n,q,x,csf,csd,f,norm,fg]=mtu0_blanch(fix(kf),fix(n),q,x,csf,csd,f,norm,fix(choice),fg);if(der==0) ;mathieuangularResult=csf;else;mathieuangularResult=csd;end;end;return;%end%**************************************************************************************************%     ==========================================================function [mathieuradialResult]=mathieuradial(parity,mkind,der,n,s,x,km,choice,varargin);%%  copyright by Danilo Erricolo%  University of Illinois at Chicago%  Oct 1, 2002%     ==========================================================%     Purpose%     Compute the Mathieu radila funcitons Re1,Re2,Re3,Re4,Ro1,Ro2,Ro3,Ro4%     parity: 0  Even, Re, ..%             1  Odd,  Ro, ...%     mkind    1,2,3,4%     der     0 No derivatives required%             1 Derivatives are required%     n       order of the Mathieu function%     s       parameter of the Mathieu function, according to the notation of Blanch%     x       argument of the Mathieu function%  km  number of terms actually computed in the series expansion of the Mathieu%             radial function%  choice  normalization requested: 1(Stratton),(2) Ince,(3) Neutral%     =============================================================%use constants;%variables required by this functionkf=[];kc=[];q=[];f1r=[];d1r=[];f2r=[];d2r=[];q=0;%     variables required by the subroutines called by this function  kf=0;  kc=0;  f1r=0;  d1r=0;  f2r=0;  d2r=0;%pi=acos(-one);%The routines of Zhang and Jin use a parameter q=s/4q=s./4;if(parity==0) ;kf=1;else;kf=2;end;%Force computation of radial functions of first and second kindkc=3;[kf,kc,n,q,x,f1r,d1r,f2r,d2r,km,choice]=mtu12_blanch(fix(kf),fix(kc),fix(n),q,x,f1r,d1r,f2r,d2r,fix(km),fix(choice));if(der==0) ;%     NO DERIVATIVES IN THE RESULTswitch(mkind);case(1);fprintf('----------------------------------1111--------------------------------\n');mathieuradialResult=f1r;case(2); fprintf('----------------------------------2222--------------------------------\n');mathieuradialResult=f2r;case(3);mathieuradialResult=f1r+sqrt(-1)*f2r;case(4);mathieuradialResult=complex(f1r,-f2r);end;else;%     DERIVATIVES requested in the resultswitch(mkind);case(1);mathieuradialResult=d1r;case(2);mathieuradialResult=d2r;case(3);mathieuradialResult=comple(d1r,d2r);case(4);mathieuradialResult=complex(d1r,-d2r);end;end;mathieuradialResult=mathieuradialResult;%sqrt(pi./2).*mathieuradialResult;% Stratton's normalization%end%***************************************************************************function [kf,kc,n,q,x,f1r,d1r,f2r,d2r,km,choice]=mtu12_blanch(kf,kc,n,q,x,f1r,d1r,f2r,d2r,km,choice,varargin);%%  by Danilo Erricolo%  University of Illinois at Chicago%  Oct 1, 2002%%     this is a modification with permission from the authors  of the subroutine%     MTU12%  originally developed and copyrighted by%  Shanjie Zhang and Jianming Jin and described in%     COMPUTATION OF SPECIAL FUNCTIONS%  JOHN WILEY & SONS, 1996%  ISBN 0-471-11963-6%%     This version was downloaded from the URL%  http://iris-lee3.ece.uiuc.edu/~jjin/jin_home.html%     where it is written that '..All the programs and subroutines contained%     in this archive are copyrighted. However, we give permission to the user%     who downloads these routines to incorporate any of these routines into his%     or her programs provided that the copyright is acknowledged. '%%%  The modifications consist of:%  1) introduced IMPLICIT NONE%     2) explicitly declared all variables%  3) introduced function KIND to allow for change of precision%  4) Removed GOTO statements%     5) Replaced call to the subroutine FCOEF that computes the Mathieu coefficients%        with a call to the subroutine Blanch_Coefficients and made%        related changes%%       ==============================================================%       Purpose: Compute modified Mathieu functions of the first and%                second kinds, Mcm(1,2,x,q) and Msm(1,2,x,q),%                and their derivatives%       Input:   KF --- Function code%                       KF=1 for computing Mcm(x,q)%                       KF=2 for computing Msm(x,q)%                KC --- Function Code%                       KC=1 for computing the first kind%                       KC=2 for computing the second kind%                            or Msm(2,x,q) and Msm(2)'(x,q)%                       KC=3 for computing both the first%                            and second kinds%                n  --- Order of Mathieu functions%                q  --- Parameter of Mathieu functions(q ? 0), according to the notation of McLachlan%                x  --- Argument of Mathieu functions%                choice  normalization requested%       Output:  F1R --- Mcm(1,x,q) or Msm(1,x,q)%                D1R --- Derivative of Mcm(1,x,q) or Msm(1,x,q)%                F2R --- Mcm(2,x,q) or Msm(2,x,q)%                D2R --- Derivative of Mcm(2,x,q) or Msm(2,x,q)% km --- number of terms actually computed in the series expansion of the Mathieu%     radial function%%%       Routines called:%(1) CVA2 for computing the characteristic values%(2) FCOEF for computing expansion coefficients%(3) JYNB for computing Jn(x), Yn(x) and their%                derivatives%       ==============================================================%use constants;kd=[];a=[];mkind=[];fg=[];norm=[];u1=[];nm=[];bj1=[];dj1=[];by1=[];dy1=[];u2=[];bj2=[];dj2=[];by2=[];dy2=[];  ic=0; k=0; kd=0; mkind=0; nm=0;  eps=1.0D-14;  a=0; c1=0; c2=0; u1=0; u2=0; w1=0; w2=0; max_ = 300; bj1=zeros(1,max_+1+1); bj2=zeros(1,max_+1+1); by1=zeros(1,max_+1+1); by2=zeros(1,max_+1+1); dj1=zeros(1,max_+1+1); dj2=zeros(1,max_+1+1); dy1=zeros(1,max_+1+1); dy2=zeros(1,max_+1+1); fg=zeros(1,max_+1);  norm=0;%Compute Mathieu eigenvalueif(kf==1&n==2.*fix(n./2)) kd=1;end;if(kf==1&n~=2.*fix(n./2)) kd=2;end;if(kf==2&n~=2.*fix(n./2)) kd=3;end;if(kf==2&n==2.*fix(n./2)) kd=4;end;[kd,n,q,a]=cva2(fix(kd),fix(n),q,a);%   Compute expansion coefficientsswitch(kd);case(1);mkind=0;case(2);mkind=1;case(3);mkind=3;case(4);mkind=2;end;[a,q,n,mkind,fg,km,norm,choice]=blanch_coefficients(a,q,fix(n),fix(mkind),fg,fix(km),norm,fix(choice));ic=fix(fix(fix(n)./2)+1);if(kd==4) ic=n./2; end;c1=exp(-x);c2=exp(x);u1=sqrt(q).*c1;u2=sqrt(q).*c2;[km,u1,nm,bj1,dj1,by1,dy1]=jynb(fix(km),u1,fix(nm),bj1,dj1,by1,dy1);[km,u2,nm,bj2,dj2,by2,dy2]=jynb(fix(km),u2,fix(nm),bj2,dj2,by2,dy2);%Evaluate Mathieu radial functionw1=0.0;w2=0.0;if((kc==1) |(kc==3)) ;f1r=0.0;for  k=1:km;if(kd==1) ;f1r=f1r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*bj1(fix(k)-1+1).*bj2(fix(k)-1+1);elseif(kd==2|kd==3) ;f1r=f1r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(bj1(fix(k)-1+1).*bj2(fix(k)+1)+(-1).^fix(kd).*bj1(fix(k)+1).*bj2(fix(k)-1+1));else;f1r=f1r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(bj1(fix(k)-1+1).*bj2(fix(k)+1+1)-bj1(fix(k)+1+1).*bj2(fix(k)-1+1));end;if(k>=5&abs(f1r-w1)<abs(f1r).*eps) break; end;w1=f1r;end;f1r=f1r./fg(1);d1r=0.0;for k=1:km;if(kd==1) ;d1r=d1r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(c2.*bj1(fix(k)-1+1).*dj2(fix(k)-1+1)-c1.*dj1(fix(k)-1+1).*bj2(fix(k)-1+1));elseif(kd==2|kd==3) ;d1r=d1r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(c2.*(bj1(fix(k)-1+1).*dj2(fix(k)+1)+(-1).^fix(kd).*bj1(fix(k)+1).*dj2(fix(k)-1+1))-c1.*(dj1(fix(k)-1+1).*bj2(fix(k)+1)+(-1).^fix(kd).*dj1(fix(k)+1).*bj2(fix(k)-1+1)));else;d1r=d1r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(c2.*(bj1(fix(k)-1+1).*dj2(fix(k)+1+1)-bj1(fix(k)+1+1).*dj2(fix(k)-1+1))-c1.*(dj1(fix(k)-1+1).*bj2(fix(k)+1+1)-dj1(fix(k)+1+1).*bj2(fix(k)-1+1)));end;if(k>=5&abs(d1r-w2)<abs(d1r).*eps) break; end;w2=d1r;end;d1r=d1r.*sqrt(q)./fg(1);end;if((kc==2) |(kc==3)) ;f2r=0.0;for k=1:km;if(kd==1) ;f2r=f2r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*bj1(fix(k)-1+1).*by2(fix(k)-1+1);elseif(kd==2|kd==3) ;f2r=f2r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(bj1(fix(k)-1+1).*by2(fix(k)+1)+(-1).^fix(kd).*bj1(fix(k)+1).*by2(fix(k)-1+1));else;f2r=f2r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(bj1(fix(k)-1+1).*by2(fix(k)+1+1)-bj1(fix(k)+1+1).*by2(fix(k)-1+1));end;if(k>=5&abs(f2r-w1)<abs(f2r).*eps) break;end;w1=f2r;end;f2r=f2r./fg(1);d2r=0.0;for k=1:km;if(kd==1) ;d2r=d2r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(c2.*bj1(fix(k)-1+1).*dy2(fix(k)-1+1)-c1.*dj1(fix(k)-1+1).*by2(fix(k)-1+1));elseif(kd==2|kd==3) ;d2r=d2r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(c2.*(bj1(fix(k)-1+1).*dy2(fix(k)+1)+(-1).^fix(kd).*bj1(fix(k)+1).*dy2(fix(k)-1+1))-c1.*(dj1(fix(k)-1+1).*by2(fix(k)+1)+(-1).^fix(kd).*dj1(fix(k)+1).*by2(fix(k)-1+1)));else;d2r=d2r+(-1).^(fix(ic)+fix(k)).*fg(fix(k)).*(c2.*(bj1(fix(k)-1+1).*dy2(fix(k)+1+1)-bj1(fix(k)+1+1).*dy2(fix(k)-1+1))-c1.*(dj1(fix(k)-1+1).*by2(fix(k)+1+1)-dj1(fix(k)+1+1).*by2(fix(k)-1+1)));end;if(k>=5&abs(d2r-w2)<abs(d2r).*eps) break; end;w2=d2r;end;d2r=d2r.*sqrt(q)./fg(1);end;%===============================================================%===============================================================function [kf,n,q,xr,csf,csd,fg,norm,choice]=mtu0_blanch(kf,n,q,xr,csf,csd,fg,norm,choice,varargin);%%%  by Danilo Erricolo%  University of Illinois at Chicago%  July 19, 2002%%     this is a modification with permission from the authors of the subroutine%     MTU0%  originally developed and copyrighted by%  Shanjie Zhang and Jianming Jin and described in%     COMPUTATION OF SPECIAL FUNCTIONS%  JOHN WILEY & SONS, 1996%  ISBN 0-471-11963-6%%     This version was downloaded from the URL%  http://iris-lee3.ece.uiuc.edu/~jjin/jin_home.html%     where it is written that '..All the programs and subroutines contained%     in this archive are copyrighted. However, we give permission to the user%     who downloads these routines to incorporate any of these routines into his%     or her programs provided that the copyright is acknowledged. '%%  The modifications consist of:%  1) introduced IMPLICIT NONE%     2) explicitly declared all variable%  3) introduced function KIND to allow for change of precision%  4) Removed GOTO statements%     5) Replaced call to the subroutine FCOEF that computes the Mathieu coefficients%        with a call to the subroutine Blanch_Coefficients and made%        related changes%     6) Modified to accept only arguments in radians%%       ===============================================================%       Purpose: Compute Mathieu functions cem(x,q) and sem(x,q)%                and their derivatives(q >= 0)%       Input :  KF  --- Function code%                        KF=1 for computing cem(x,q) and cem'(x,q)%                        KF=2 for computing sem(x,q) and sem'(x,q)%               n   --- Order of Mathieu functions%               q   --- Parameter of Mathieu functions%               xr   --- Argument of Mathieu functions(IN RADIANS - MODIFIED BY DANILO ERRICOLO)%      Output:  CSF --- cem(x,q) or sem(x,q)%               CSD --- cem'x,q) or sem'x,q)%               FG  --- Expansion coefficient of the Mathieu angular function%      Routines called:%(1) CVA2 to compute the characteristic values%(2) Blanch_Coefficients to compute the expansion coefficients%======================================================%use constants;kd=[];a=[];mkind=[];km=[];  ic=0; kd=0; k=0; km=0; mkind=0; eps=1.0D-14;  a=0;if(kf==1&n==2.*fix(n./2)) kd=1;end;if(kf==1&n~=2.*fix(n./2)) kd=2; end;if(kf==2&n~=2.*fix(n./2)) kd=3;end;if(kf==2&n==2.*fix(n./2)) kd=4;end;%Compute Mathieu eigenvalueswitch(kd);case(1);mkind=0;case(2);mkind=1;case(3);mkind=3;case(4);mkind=2;end;[kd,n,q,a]=cva2(fix(kd),fix(n),q,a);%Compute expansion coefficients[a,q,n,mkind,fg,km,norm,choice]=blanch_coefficients(a,q,fix(n),fix(mkind),fg,fix(km),norm,fix(choice));%Evaluate Mathieu angular functionic=fix(fix(fix(n)./2)+1);csf=0;%zerofor k=1:km;if(kd==1) ;csf=csf+fg(fix(k)).*cos((2.*fix(k)-2).*xr);elseif(kd==2) ;csf=csf+fg(fix(k)).*cos((2.*fix(k)-1).*xr);elseif(kd==3) ;csf=csf+fg(fix(k)).*sin((2.*fix(k)-1).*xr);elseif(kd==4) ;csf=csf+fg(fix(k)).*sin(2.*fix(k).*xr);end;if(k>=ic&abs(fg(k))<abs(csf).*eps) break;end;end;csd=0.0;%zerofor k=1:km;if(kd==1) ;csd=csd-(2.*fix(k)-2).*fg(fix(k)).*sin((2.*fix(k)-2).*xr);elseif(kd==2) ;csd=csd-(2.*fix(k)-1).*fg(fix(k)).*sin((2.*fix(k)-1).*xr);elseif(kd==3) ;csd=csd+(2.*fix(k)-1).*fg(fix(k)).*cos((2.*fix(k)-1).*xr);elseif(kd==4) ;csd=csd+2.0D0.*fix(k).*fg(fix(k)).*cos(2.*fix(k).*xr);end;if(k>=ic&abs(fg(k))<abs(csd).*eps) break;end;end;%end; subroutine%=============================================================%=======================================================function [a,q,order,mkind,d_m,k_max,norm,choice]=blanch_coefficients(a,q,order,mkind,d_m,k_max,norm,choice,varargin);%=======================================================% copyright by Danilo Erricolo% University of Illinois at Chicago% Oct 14, 2002%% Purpose%% Compute the expansion coefficients of the series that represents the% Mathieu function. The subroutine implements the algorithm developed by% Gertrude Blanch and described in: 'Numerical Aspects of Mathieu eigenvalues',% in Rend. Circ. Mat. Paler. Series II, vol. 15. 51--97, 1966.%% INPUT% A: eigenvalue of the Mathieu equation that corresponds to a solution of order 'm' and type given by 'kind'% Q: parameter% order: order of the Mathieu function% mkind: assumes four possible values%        0 - even solution of period pi% 1 - even solution with period 2*pi% 2 - odd solution of period pi%        3 - odd solution of period 2*pi%% choice:parameter that selects the type of nomrlaization according to% 1 - Morse-Stratton%        2 - Ince%        3 - Neutral% OUTPUT% D_m:   array of expansion coefficients% k_max: Number of cofficients contained in D_m% norm:  normalization coefficient, only provided when 'choice==2'% This subroutine uses the integer parameter 'exp_coeff_factor' defined in the module constants.f90% Its purpose is to force the computation of a number of expansion coeffiencients that is at least exp_coeff_factor*order/2% When this subroutine is run at double precision, a good number for exp_coeff_factor is 4. In case of quadruple precision,% a good number is 7.%use constants;a_m=[];m1=[];m_max=[];  k=0; m=0; m_max=0; m_add=0; m_start=0; m2s=0; m1=0;  f_m=0; tm=0; tm_p=0; u=0; fl=0; max_=300;  g_1=zeros(1,max_); g_2=zeros(1,max_); h_m=zeros(1,max_);  a_m=zeros(1,max_+1);  loop=false;  additional_terms=false;%pi=acos(-one);a_m(0+1)=0.0;%zero;max = 300; %%%%%%%%%%%%check%%%%%%%%%%%%%for m=1:max;g_2(m)=0.0;g_1(m)=0.0;a_m(m+1)=0.0;end; m=fix(max+1);%*********% STAGE 1%*********fl=2.0D0.^126;%determine the initial value of m and G_1,m according to the value of kindswitch(mkind);case(0);m_start=2;g_1(1)=v(0,a,q);case(1);m_start=3;g_1(1)=v(1,a,q)-1.0;case(2);m_start=4;g_1(1)=v(2,a,q);case(3);m_start=3;g_1(1)=v(1,a,q)+1.0;end;m=fix(fix(m_start));if(q > 0.0) ;%Computation of M2S=2*s according to 1.91u=0.5.*sqrt(3.0D0.*q+a);m2s=fix(2.*floor(u)+fix(m)+4);%Computation of coefficients Gm,1 according to 1.10 and 1.11 and Appendix 2h_m(1)=1./g_1(1);m=fix(fix(m_start));while(m<m2s);m=fix(fix(m)+2);k=fix((fix(m)-fix(m_start))./2+1);g_1(k)=v(fix(m)-2,a,q)-cm(fix(m)-4).*h_m(fix(k)-1);h_m(k)=1./g_1(fix(k));if(abs(g_1(k))<1.0) break; end;end;m1=fix(fix(m));%set starting value of chaining coefficientif((m==m2s) &(abs(g_1(k))>one)) ;%execute backtracking routineg_2(k)=tail(fix(m2s),a,q);tm_p=g_2(fix(k))-g_1(fix(k));%previous value of Tm functionm1=fix(fix(m));while(m-m_start>0);%statement(2.14)m=fix(fix(m)-2);k=fix(fix(k)-1);g_2(k)=cm(fix(m)-2)./(v(fix(m),a,q)-g_2(fix(k)+1));tm=g_2(fix(k))-g_1(fix(k));if(abs(tm)>abs(tm_p)) ;m1=fix(fix(m)+2);break;else;tm_p=tm;m1=fix(fix(m));end;end;end;%***************%STAGE 2 and 3%Note that we don't need to track the values of Tm since we already have available a good approximation for%the eigenvalue a%***************if(m1<m2s) ;k=fix((fix(m2s)-fix(m_start))./2+1);g_2(k)=tail(fix(m2s),a,q);m=fix(fix(m2s)-2);k=fix(fix(k)-1);while(m>=m1);%outer whileh_m(k)=hm2(fix(m),a,q,g_2,fix(m_start));if(abs(h_m(k))>=1.0) ;g_2(k)=1./h_m(fix(k));h_m(k)=fl;else;loop=true;while(loop);if(m==m1) ;if(abs(h_m(k))==zero) ;fprintf(1,'%s \n','fatal error');else;g_2(k)=1./h_m(fix(k));h_m(k)=fl;end;loop=false;else;g_2(k)=fl;m=fix(fix(m)-2);k=fix(fix(k)-1);f_m=fm(fix(m),a,q,h_m,fix(m_start));if(abs(f_m)>=abs(h_m(k+1))) ;g_2(k)=h_m(fix(k)+1)./f_m;loop=false;h_m(k)=fl;else;h_m(k)=f_m./h_m(fix(k)+1);g_2(k)=fl;end;end;end;end;m=fix(fix(m)-2);k=fix(fix(k)-1);end;end;%Start computing coefficients according to normalization 2m=fix(fix(m1)-2);k=fix((fix(m)-fix(m_start))./2+1);a_m(k+1)=1.0;k=fix(fix(k)-1);while(k>=0);a_m(k+1)=a_m(fix(k)+1+1)./g_1(fix(k)+1);k=fix(fix(k)-1);end;m=fix(fix(m1));k=fix((fix(m)-fix(m_start))./2+1);while(m<=m2s);if(g_2(k)>=fl) ;a_m(k+1)=a_m(fix(k)-2+1)./fm(fix(m),a,q,h_m,fix(m_start));else;a_m(k+1)=g_2(fix(k)).*a_m(fix(k)-1+1);end;m=fix(fix(m)+2);k=fix(fix(k)+1);end;%Now compute the additional number of coefficients m_add necessary to obtain a truncation error%below some specified tolerance TOL. Hence evaluate 6.04 and 6.05tol=6.05;%%%%%%%%%%%Attentiontol=1.0E-40;m=fix(fix(m2s));k=fix((fix(m)-fix(m_start))./2+1);m_add=fix(ceil(log(abs(a_m(fix(k)+1)./tol))./log(1./abs(g_2(fix(k)))))+1);additional_terms=false;if(m_add>0) ;m_max=fix(fix(m2s)+fix(m_add)+2);additional_terms=true;end;exp_coeff_factor=5;%   Modify Blanch's algorithm to force that the number of coefficients computed is at least as large as the orderif(m_max<exp_coeff_factor.*order) ;m_max=fix(exp_coeff_factor.*fix(order));additional_terms=true;end;if(additional_terms) ;%Compute the additional G_{m,2} that are requiredm=fix(fix(m_max));k=fix((fix(m)-fix(m_start))./2+1);g_2(k)=tail(fix(m),a,q);m=fix(fix(m)-2);k=fix(fix(k)-1);while(m>m2s);g_2(k)=cm(fix(m)-2)./(v(fix(m),a,q)-g_2(fix(k)+1));m=fix(fix(m)-2);k=fix(fix(k)-1);end;%Compute the additional remaining coefficients A_m according to the normalization(2)while(m<=m_max);a_m(k+1)=g_2(fix(k)).*a_m(fix(k)-1+1);m=fix(fix(m)+2);k=fix(fix(k)+1);end;end;[mkind,choice,a_m,m1,m_max,d_m,norm]=normalization(fix(mkind),fix(choice),a_m,fix(m1),fix(m_max),d_m,norm);k_max=fix(fix(m_max)./2+1);else;%when q=0 only one coefficient is different from zerok=fix((fix(order)-fix(m_start))./2+1);m_max=fix(fix(order));%normalize coefficientsif(choice==1) ;if(mkind<=1) ;d_m(k+1)=1.0;else;d_m(k+1)=1.0./fix(order);end;if((mkind==1) &(order==0)) ;norm=2.*pi.*d_m(0+1).^2;else;norm=pi.*d_m(fix(k)+1).^2;end;elseif(choice==2) ;if((mkind==0) &(order==0)) ;d_m(k+1)=1./sqrt(2.0D0);else;d_m(k+1)=1.0;end;else;d_m(k+1)=1.0;end;k_max=fix(fix(k));end;%end%************************************************************************************************%************************************************************************************************function [mkind,choice,a_m,m1,m_max,b_m,norm]=normalization(mkind,choice,a_m,m1,m_max,b_m,norm,varargin);%  copyright by Danilo Erricolo%  University of Illinois at Chicago%  July 19, 2002% choice==1 Stratton% choice==2 Ince% choice==3 Neutral% norm returns a normalization coefficient only for Stratton's normalization%use constants;  k=0; k1=0; k2=0; k3=0; m_start=0; p=0;  a=0;  sum1=0; sum2=0; sum_sq=0; sum_sq1=0; sum_sq2=0;%pi=acos(-one);switch(mkind);    case(0);m_start=2;case(1);m_start=3;case(2);m_start=4;p=2;case(3);m_start=3;p=1;end;if(choice==1) ;% Stratton's normalizationsum1=0.0;sum2=0.0;sum_sq1=0.0;sum_sq2=0.0;k1=fix(((fix(m1)-2)-fix(m_start))./2+1);k2=fix((fix(m1)-fix(m_start))./2+1);k3=fix((fix(m_max)-fix(m_start))./2+1);%compute sum of all coefficients starting from the numbers smaller in magnitudeif(mkind<=1) ;for k=0:k1;sum1=sum1+a_m(fix(k)+1);end;k=fix(fix(k1)+1);for k=k3:-1:k2;sum2=sum2+a_m(fix(k)+1);end;k=fix(fix(k2)-1);else;for k=0:k1;sum1=sum1+(2.*fix(k)+fix(p)).*a_m(fix(k)+1);end;k=fix(fix(k1)+1);for k=k3:-1:k2;sum2=sum2+(2.*fix(k)+fix(p)).*a_m(fix(k)+1);end; k=fix(fix(k2)-1);end;%Compute the sum of the squares of the coefficients starting from the numbers smaller in magnitudefor k=0:k1;sum_sq1=sum_sq1+a_m(fix(k)+1).^2;end; k=fix(fix(k1)+1);for k=k3:-1:k2;sum_sq2=sum_sq2+a_m(fix(k)+1).^2;end; k=fix(fix(k2)-1);%rinormalize all coefficientssum=sum1+sum2;for k=0:k3;b_m(k+1)=a_m(fix(k)+1)./sum;end; k=fix(fix(k3)+1);%compute normalization coefficient of Strattonif(mkind==0) ;norm=pi.*(sum_sq1+sum_sq2+a_m(0+1).^2)./sum.^2;else;norm=pi.*(sum_sq1+sum_sq2)./sum.^2;end;elseif(choice==2) ;% Ince's normalization%compute sum of all coefficients starting from the numbers smaller in magnitudesum_sq1=0.0;%zero;k1=fix(((fix(m1)-2)-fix(m_start))./2+1);for k=0:k1;sum_sq1=sum_sq1+a_m(fix(k)+1).^2;end; k=fix(fix(k1)+1);sum_sq2=0.0;k3=fix((fix(m_max)-fix(m_start))./2+1);k2=fix((fix(m1)-fix(m_start))./2+1);for k=k3:-1:k2;sum_sq2=sum_sq2+a_m(fix(k)+1).^2;end; k=fix(fix(k2)-1);if(mkind==0) ;sum_sq=sqrt(sum_sq1+sum_sq2+a_m(0+1).^2).*a_m(0+1)./abs(a_m(0+1));else;sum_sq=sqrt(sum_sq1+sum_sq2).*a_m(0+1)./abs(a_m(0+1));end;%rinormalize all coefficientsfor k=0:k3;b_m(k+1)=a_m(fix(k)+1)./sum_sq;end; k=fix(fix(k3)+1);norm=1.0;%one;%this coefficient is not useful for Ince's normalizationelse;%Neutral normalization%Find the largest element in magnitudea=a_m(0+1);k1=fix((fix(m_max)-fix(m_start))./2+1);for k=1:k1;if(abs(a_m(k+1))>abs(a)) ;a=a_m(fix(k)+1);end;end; k=fix(fix(k1)+1);%rinormalize all coefficientsfor k=0:k1;b_m(k+1)=a_m(fix(k)+1)./a;end; k=fix(fix(k1)+1);norm=-1.0;%-one;end;%end%************************************************************************************************function [cmResult]=cm(m,varargin);%=========================================% returns cm as defined by 1.051%  copyright by Danilo Erricolo%  University of Illinois at Chicago%  July 19, 2002if(m==0) ;cmResult=2;else;cmResult=1;end;%end%=========================================%=========================================function [vResult]=v(m,a,q,varargin);%=========================================%use constants;vResult=(a-fix(m).*fix(m))./q;%end%=========================================%===========================================function [tailResult]=tail(m2s,alpha,q,varargin);%===========================================%use constants;  k=0; mf=0;  a=0; ap=0; app=0; b=0; bp=0; bpp=0; bk=0; c=0; q_k=0; q_p=0;%COMPUTATION OF THE TAIL OF THE CONTINUED FRACTION according to Method 1 of Appendix 1app= 1.0;ap=  0.0;bpp= 0.0;bp=  1.0;k=1;bk=v(fix(m2s),alpha,q);a=bk.*ap+app;b=bk.*bp+bpp;q_k=a./b;q_p=0.0;app=ap;ap=a;bpp=bp;bp=b;tol=1.0E-40;while(abs(q_k-q_p)>tol);k=fix(fix(k)+1);mf=fix(fix(m2s)+2.*(fix(k)-1));bk=(alpha-(fix(m2s)+2.*(fix(k)-1)).^2)./q;a=bk.*ap-app;b=bk.*bp-bpp;q_p=q_k;q_k=a./b;app=ap;ap=a;bpp=bp;bp=b;end;%Computation of the tail of the continued fraction according to Method 3 of Appendix Ic=0.0;k=fix(fix(mf)-2);while (1);c=1./(v(fix(k),alpha,q)-c);if(k==m2s) break; end;k=fix(fix(k)-2);end;tailResult=0.5D0.*(q_k+c);%end%=========================================function [hm2Result]=hm2(m,a,q,g_2,m_start,varargin);%% This function accepts as input the array G_2. The positions of the elements% inside G_2 are related to the index m according to% k=(m-m_start)/2+1%  copyright by Danilo Erricolo%  University of Illinois at Chicago%  July 19, 2002%=========================================%use constants;  k=0; vm=0;%compute Hm,2k=fix(((fix(m)+2)-fix(m_start))./2+1);if(m>=m_start+2) ;vm=(a-fix(m).*fix(m))./q;hm2Result=vm-g_2(fix(k));else;hm2Result=(vm-g_2(fix(k)))./2.0D0;end;%end%=========================================%=========================================function [fmResult]=fm(m,a,q,h_m,m_start,varargin);%% This function accepts as input the array G_2. The positions of the elements% inside G_2 are related to the index m according to% k=(m-m_start)/2+1%=========================================%use constants;  k=0; vm=0;k=fix(((fix(m)+2)-fix(m_start))./2+1);if(m>=m_start+2) ;vm=(a-fix(m).*fix(m))./q;fmResult=vm.*h_m(fix(k))-1.0;%  - oneelse;fmResult=(vm.*h_m(fix(k))-one)./2.0D0;end;%end; %function;%=========================================%end module  blanchfunction [kd,m,q,a]=cva2(kd,m,q,a);%     ======================================================%     Purpose: Calculate a specific characteristic value of%     Mathieu functions%     Input :  m  --- Order of Mathieu functions%     q  --- Parameter of Mathieu functions%     KD --- Case code%     KD=1 for cem(x,q)  ( m = 0,2,4,...)%     KD=2 for cem(x,q)  ( m = 1,3,5,...)%     KD=3 for sem(x,q)  ( m = 1,3,5,...)%     KD=4 for sem(x,q)  ( m = 2,4,6,...)%     Output:  A  --- Characteristic value%     Routines called:%     (1) REFINE for finding accurate characteristic%     value using an iteration method%     (2) CV0 for finding initial characteristic%     values using polynomial approximation%     (3) CVQM for computing initial characteristic%     values for q ? 3*m%     (3) CVQL for computing initial characteristic%     values for q ? m*m%     ======================================================q1=[];a1=[];q2=[];a2=[];qq=[];iflag=[];if (m <= 12|q <= 3.0.*m|q > m.*m);[kd,m,q,a]=cv0(kd,m,q,a);if (q ~= 0.0d0);[kd,m,q,a]=refine(kd,m,q,a,1);end;else;ndiv=10;delta=(m-3.0).*m./ndiv;if ((q-3.0.*m) <= (m.*m-q));while (1);nn=fix((q-3.0.*m)./delta)+1;delta=(q-3.0.*m)./nn;q1=2.0.*m;[m,q1,a1]=cvqm(m,q1,a1);q2=3.0.*m;[m,q2,a2]=cvqm(m,q2,a2);qq=3.0.*m;for  i=1:nn;qq=qq+delta;a=(a1.*q2-a2.*q1+(a2-a1).*qq)./(q2-q1);iflag=1;if (i == nn) iflag=-1; end;[kd,m,qq,a]=refine(kd,m,qq,a,iflag);q1=q2;q2=qq;a1=a2;a2=a;end;            if (iflag == -1);%michael, was -10ndiv=ndiv.*2;delta=(m-3.0).*m./ndiv;break;end;end;else;while (1);nn=fix((m.*m-q)./delta)+1;delta=(m.*m-q)./nn;q1=m.*(m-1.0);[kd,m,q1,a1]=cvql(kd,m,q1,a1);q2=m.*m;[kd,m,q2,a2]=cvql(kd,m,q2,a2);qq=m.*m;for  i=1:nn;qq=qq-delta;a=(a1.*q2-a2.*q1+(a2-a1).*qq)./(q2-q1);iflag=1;if (i == nn) iflag=-1; end;[kd,m,qq,a]=refine(kd,m,qq,a,iflag);q1=q2;q2=qq;a1=a2;a2=a;end;            if (iflag == -1);%michael, was -10ndiv=ndiv.*2;delta=(m-3.0).*m./ndiv;break;end;end;end;end;function [kd,m,q,a]=refine(kd,m,q,a,iflag);%     =====================================================%     Purpose: calculate the accurate characteristic value%     by the secant method%     Input :  m --- Order of Mathieu functions%     q --- Parameter of Mathieu functions%     A --- Initial characteristic value%     Output:  A --- Refineed characteristic value%     Routine called:  CVF for computing the value of F for%     characteristic equation%     ========================================================x0=[];mj=[];f0=[];x1=[];f1=[];x=[];f=[];eps=1.0d-14;mj=10+m;x0=a;[kd,m,q,x0,mj,f0]=cvf(kd,m,q,x0,mj,f0);x1=1.002.*a;[kd,m,q,x1,mj,f1]=cvf(kd,m,q,x1,mj,f1);for  it=1:100;mj=mj+1;x=x1-(x1-x0)./(1.0d0-f0./f1);[kd,m,q,x,mj,f]=cvf(kd,m,q,x,mj,f);if (abs(1.0-x1./x) < eps|f == 0.0) break; end;x0=x1;f0=f1;x1=x;f1=f;end;a=x;function [kd,m,q,a,mj,f]=cvf(kd,m,q,a,mj,f);%     ======================================================%     Purpose: Compute the value of F for characteristic%     equation of Mathieu functions%     Input :  m --- Order of Mathieu functions%     q --- Parameter of Mathieu functions%     A --- Characteristic value%     Output:  F --- Value of F for characteristic equation%     ======================================================b=a;ic=fix(m./2);l=0;l0=0;j0=2;jf=ic;if (kd == 1) l0=2; end;if (kd == 1) j0=3; end;if (kd == 2|kd == 3) l=1; end;if (kd == 4) jf=ic-1; end;t1=0.0d0;for  j=mj:-1:ic+1;t1=-q.*q./((2.0d0.*j+l).^2-b+t1);end;if (m <= 2);t2=0.0d0;if (kd == 1&m == 0);t1=t1+t1;end;if (kd == 1&m == 2);t1=-2.0.*q.*q./(4.0-b+t1)-4.0;end;if (kd == 2&m == 1) t1=t1+q; end;if (kd == 3&m == 1) t1=t1-q; end;else;if (kd == 1) t0=4.0d0-b+2.0d0.*q.*q./b; end;if (kd == 2) t0=1.0d0-b+q; end;if (kd == 3) t0=1.0d0-b-q; end;if (kd == 4) t0=4.0d0-b; end;t2=-q.*q./t0;for  j=j0:jf;t2=-q.*q./((2.0d0.*j-l-l0).^2-b+t2);end;end;f=(2.0d0.*ic+l).^2+t1+t2-b;function [kd,m,q,a0]=cv0(kd,m,q,a0);%     =====================================================%     Purpose: Compute the initial characteristic value of%     Mathieu functions for m ? 12  or q ? 300 or%     q ? m*m%     Input :  m  --- Order of Mathieu functions%     q  --- Parameter of Mathieu functions%     Output:  A0 --- Characteristic value%     Routines called:%     (1) CVQM for computing initial characteristic%     value for q ? 3*m%     (2) CVQL for computing initial characteristic%     value for q ? m*m%     ====================================================q2=q.*q;if (m == 0);if (q <= 1.0);a0=(((.0036392.*q2-.0125868).*q2+.0546875).*q2-.5).*q2;elseif (q <= 10.0);a0=((3.999267d-3.*q-9.638957d-2).*q-.88297).*q +.5542818;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m == 1);if (q <= 1.0&kd == 2);a0=(((-6.51e-4.*q-.015625).*q-.125).*q+1.0).*q+1.0;elseif (q <= 1.0&kd == 3);a0=(((-6.51e-4.*q+.015625).*q-.125).*q-1.0).*q+1.0;elseif (q <= 10.0& kd == 2);a0=(((-4.94603d-4.*q+1.92917d-2).*q-.3089229) .*q+1.33372).*q+.811752;elseif (q <= 10.0&kd == 3);a0=((1.971096d-3.*q-5.482465d-2).*q-1.152218) .*q+1.10427;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m == 2);if (q <= 1.0&kd == 1);a0=(((-.0036391.*q2+.0125888).*q2-.0551939).*q2 +.416667).*q2+4.0;elseif (q <= 1.0&kd == 4);a0=(.0003617.*q2-.0833333).*q2+4.0;elseif (q <= 15&kd == 1);a0=(((3.200972d-4.*q-8.667445d-3).*q -1.829032d-4).*q+.9919999).*q+3.3290504;elseif (q <= 10.0&kd == 4);a0=((2.38446d-3.*q-.08725329).*q-4.732542d-3) .*q+4.00909;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m == 3);if (q <= 1.0&kd == 2);a0=((6.348e-4.*q+.015625).*q+.0625).*q2+9.0;elseif (q <= 1.0&kd == 3);a0=((6.348e-4.*q-.015625).*q+.0625).*q2+9.0;elseif (q <= 20.0&kd == 2);a0=(((3.035731d-4.*q-1.453021d-2).*q +.19069602).*q-.1039356).*q+8.9449274;elseif (q <= 15.0&kd == 3);a0=((9.369364d-5.*q-.03569325).*q+.2689874).*q +8.771735;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m == 4);if (q <= 1.0&kd == 1);a0=((-2.1e-6.*q2+5.012e-4).*q2+.0333333).*q2+16.0;elseif (q <= 1.0&kd == 4);a0=((3.7e-6.*q2-3.669e-4).*q2+.0333333).*q2+16.0;elseif (q <= 25.0&kd == 1);a0=(((1.076676d-4.*q-7.9684875d-3).*q +.17344854).*q-.5924058).*q+16.620847;elseif (q <= 20.0&kd == 4);a0=((-7.08719d-4.*q+3.8216144d-3).*q +.1907493).*q+15.744;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m == 5);if (q <= 1.0&kd == 2);a0=((6.8e-6.*q+1.42e-5).*q2+.0208333).*q2+25.0;elseif (q <= 1.0&kd == 3);a0=((-6.8e-6.*q+1.42e-5).*q2+.0208333).*q2+25.0;elseif (q <= 35.0&kd == 2);a0=(((2.238231d-5.*q-2.983416d-3).*q +.10706975).*q-.600205).*q+25.93515;elseif (q <= 25.0&kd == 3);a0=((-7.425364d-4.*q+2.18225d-2).*q +4.16399d-2).*q+24.897;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m == 6);if (q <= 1.0);a0=(.4d-6.*q2+.0142857).*q2+36.0;elseif (q <= 40.0&kd == 1);a0=(((-1.66846d-5.*q+4.80263d-4).*q +2.53998d-2).*q-.181233).*q+36.423;elseif (q <= 35.0&kd == 4);a0=((-4.57146d-4.*q+2.16609d-2).*q-2.349616d-2).*q +35.99251;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m == 7);if (q <= 10.0);[m,q,a0]=cvqm(m,q,a0);elseif (q <= 50.0&kd == 2);a0=(((-1.411114d-5.*q+9.730514d-4).*q -3.097887d-3).*q+3.533597d-2).*q+49.0547;elseif (q <= 40.0&kd == 3);a0=((-3.043872d-4.*q+2.05511d-2).*q -9.16292d-2).*q+49.19035;else;[kd,m,q,a0]=cvql(kd,m,q,a0);end;elseif (m >= 8);if (q <= 3..*m);[m,q,a0]=cvqm(m,q,a0);elseif (q > m.*m);[kd,m,q,a0]=cvql(kd,m,q,a0);else;if (m == 8&kd == 1);a0=(((8.634308d-6.*q-2.100289d-3).*q+.169072).*q -4.64336).*q+109.4211;elseif (m == 8&kd == 4);a0=((-6.7842d-5.*q+2.2057d-3).*q+.48296).*q+56.59;elseif (m == 9&kd == 2);a0=(((2.906435d-6.*q-1.019893d-3).*q+.1101965).*q -3.821851).*q+127.6098;elseif (m == 9&kd == 3);a0=((-9.577289d-5.*q+.01043839).*q+.06588934).*q +78.0198;elseif (m == 10&kd == 1);a0=(((5.44927d-7.*q-3.926119d-4).*q+.0612099).*q -2.600805).*q+138.1923;elseif (m == 10&kd == 4);a0=((-7.660143d-5.*q+.01132506).*q-.09746023).*q +99.29494;elseif (m == 11&kd == 2);a0=(((-5.67615d-7.*q+7.152722d-6).*q+.01920291).*q -1.081583).*q+140.88;elseif (m == 11&kd == 3);a0=((-6.310551d-5.*q+.0119247).*q-.2681195).*q +123.667;elseif (m == 12&kd == 1);a0=(((-2.38351d-7.*q-2.90139d-5).*q+.02023088).*q -1.289).*q+171.2723;elseif (m == 12&kd == 4);a0=(((3.08902d-7.*q-1.577869d-4).*q+.0247911).*q -1.05454).*q+161.471;end;end;end;function [kd,m,q,a0]=cvql(kd,m,q,a0);%     ========================================================%     Purpose: Compute the characteristic value of Mathieu%     functions  for q ? 3m%     Input :  m  --- Order of Mathieu functions%     q  --- Parameter of Mathieu functions%     Output:  A0 --- Initial characteristic value%     ========================================================if (kd == 1|kd == 2) w=2.0d0.*m+1.0d0; end;if (kd == 3|kd == 4) w=2.0d0.*m-1.0d0; end;w2=w.*w;w3=w.*w2;w4=w2.*w2;w6=w2.*w4;d1=5.0+34.0./w2+9.0./w4;d2=(33.0+410.0./w2+405.0./w4)./w;d3=(63.0+1260.0./w2+2943.0./w4+486.0./w6)./w2;d4=(527.0+15617.0./w2+69001.0./w4+41607.0./w6)./w3;c1=128.0;p2=q./w4;p1=sqrt(p2);cv1=-2.0.*q+2.0.*w.*sqrt(q)-(w2+1.0)./8.0;cv2=(w+3.0./w)+d1./(32.0.*p1)+d2./(8.0.*c1.*p2);cv2=cv2+d3./(64.0.*c1.*p1.*p2)+d4./(16.0.*c1.*c1.*p2.*p2);a0=cv1-cv2./(c1.*p1);function [m,q,a0]=cvqm(m,q,a0);%     =====================================================%     Purpose: Compute the characteristic value of Mathieu%     functions for q ? m*m%     Input :  m  --- Order of Mathieu functions%     q  --- Parameter of Mathieu functions%     Output:  A0 --- Initial characteristic value%     =====================================================hm1=.5.*q./(m.*m-1.0);hm3=.25.*hm1.^3./(m.*m-4.0);hm5=hm1.*hm3.*q./((m.*m-1.0).*(m.*m-9.0));a0=m.*m+q.*(hm1+(5.0.*m.*m+7.0).*hm3 +(9.0.*m.^4+58.0.*m.*m+29.0).*hm5);function [n,x,nm,bj,dj,by,dy]=jynb(n,x,nm,bj,dj,by,dy);%                their derivatives%       Input :  x --- Argument of Jn(x) and Yn(x) ( x ? 0 )%                n --- Order of Jn(x) and Yn(x)%       Output:  BJ(n) --- Jn(x)%                DJ(n) --- Jn'(x)%                BY(n) --- Yn(x)%                DY(n) --- Yn'(x)%                NM --- Highest order computed%       Routines called:%                MSTA1 and MSTA2 to calculate the starting%                point for backward recurrence%       =====================================================%%%%%%%%a=zeros(4,1);b=zeros(4,1);a1=zeros(4,1);b1=zeros(4,1);r2p=.63661977236758d0;nm=n;if (x < 1.0d-100) ;for  k=0:n;bj(k+1)=0.0d0;dj(k+1)=0.0d0;by(k+1)=-1.0d+300;dy(k+1)=1.0d+300;end;bj(0+1)=1.0d0;dj(1+1)=0.5d0;return;end;if (x <= 300.0|n > fix(0.9.*x)) ;if (n == 0) nm=1; end;m=msta1(x,200);if (m < nm) ;nm=m;else;m=msta2(x,nm,15);end;bs=0.0d0;su=0.0d0;sv=0.0d0;f2=0.0d0;f1=1.0d-100;for  k=m:-1:0;f=2.0d0.*(k+1.0d0)./x.*f1-f2;if (k <= nm) bj(k+1)=f; end;if (k == 2.*fix(k./2)&k ~= 0) ;bs=bs+2.0d0.*f;su=su+(-1).^(k./2).*f./k;elseif (k > 1);sv=sv+(-1).^(k./2).*k./(k.*k-1.0).*f;end;f2=f1;f1=f;end;s0=bs+f;for  k=0:nm;bj(k+1)=bj(k+1)./s0;end;ec=log(x./2.0d0)+0.5772156649015329d0;by0=r2p.*(ec.*bj(0+1)-4.0d0.*su./s0);by(0+1)=by0;by1=r2p.*((ec-1.0d0).*bj(1+1)-bj(0+1)./x-4.0d0.*sv./s0);by(1+1)=by1;else;a=[-.7031250000000000d-01,.1121520996093750d+00,-.5725014209747314d+00,.6074042001273483d+01];b=[.7324218750000000d-01,-.2271080017089844d+00,.1727727502584457d+01,-.2438052969955606d+02];a1=[.1171875000000000d+00,-.1441955566406250d+00,.6765925884246826d+00,-.6883914268109947d+01];b1=[-.1025390625000000d+00,.2775764465332031d+00,-.1993531733751297d+01,.2724882731126854d+02];t1=x-0.25d0.*pi;p0=1.0d0;q0=-0.125d0./x;for  k=1:4;p0=p0+a(k).*x.^(-2.*k);q0=q0+b(k).*x.^(-2.*k-1);end;cu=sqrt(r2p./x);bj0=cu.*(p0.*cos(t1)-q0.*sin(t1));by0=cu.*(p0.*sin(t1)+q0.*cos(t1));bj(0+1)=bj0;by(0+1)=by0;t2=x-0.75d0.*pi;p1=1.0d0;q1=0.375d0./x;for  k=1:4;p1=p1+a1(k).*x.^(-2.*k);q1=q1+b1(k).*x.^(-2.*k-1);end;bj1=cu.*(p1.*cos(t2)-q1.*sin(t2));by1=cu.*(p1.*sin(t2)+q1.*cos(t2));bj(1+1)=bj1;by(1+1)=by1;for  k=2:nm;bjk=2.0d0.*(k-1.0d0)./x.*bj1-bj0;bj(k+1)=bjk;bj0=bj1;bj1=bjk;end;end;dj(0+1)=-bj(1+1);for  k=1:nm;dj(k+1)=bj(k-1+1)-k./x.*bj(k+1);end;for  k=2:nm;byk=2.0d0.*(k-1.0d0).*by1./x-by0;by(k+1)=byk;by0=by1;by1=byk;end;dy(0+1)=-by(1+1);for  k=1:nm;dy(k+1)=by(k-1+1)-k.*by(k+1)./x;end;return;function [msta1]=msta1(x,mp);%                recurrence such that the magnitude of%                Jn(x) at that point is about 10^(-MP)%       Input :  x     --- Argument of Jn(x)%                MP    --- Value of magnitude%       Output:  MSTA1 --- Starting point%       ===================================================%%%a0=abs(x);n0=fix(1.1.*a0)+1;f0=envj(n0,a0)-mp;n1=n0+5;f1=envj(n1,a0)-mp;for  it=1:20;nn=n1-(n1-n0)./(1.0d0-f0./f1);f=envj(nn,a0)-mp;if(abs(nn-n1) < 1) break; end;n0=n1;f0=f1;n1=nn;f1=f;end;msta1=fix(nn);return;function [msta2]=msta2(x,n,mp);%                recurrence such that all Jn(x) has MP%                significant digits%       Input :  x  --- Argument of Jn(x)%                n  --- Order of Jn(x)%                MP --- Significant digit%       Output:  MSTA2 --- Starting point%       ===================================================%%%%a0=abs(x);hmp=0.5d0.*mp;ejn=envj(n,a0);if (ejn <= hmp) ;obj=mp;n0=fix(1.1.*a0);else;obj=hmp+ejn;n0=n;end;f0=envj(n0,a0)-obj;n1=n0+5;f1=envj(n1,a0)-obj;for  it=1:20;nn=n1-(n1-n0)./(1.0d0-f0./f1);f=envj(nn,a0)-obj;if (abs(nn-n1) < 1) break; end;n0=n1;f0=f1;n1=nn;f1=f;end;msta2=fix(nn+10);return;function [envj]=envj(n,x);%envj=0.5d0.*log10(6.28d0.*n)-n.*log10(1.36d0.*x./n);return;function y = MCY(m, z, q)%% Computes the even radial Mathieu function% associated with the Bessel function Y% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable positive%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(4*m, 100);    upper = q*ones(n,1);  middle = 4*(0:(n-1))'.^2;  lower = q*ones(n,1);  lower(1) = lower(1) + q;  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sr', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);      endend  mp = (m+2)/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = (-1).^(0:(n-1))'.*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:(n-1))', u1(ii));    zu2 = bessely((0:(n-1))', u2(ii));    y(ii) = y(ii) + coeff'*( ju1(1:n).*zu2(1:n) );end  y = y*(-1)^(m/2)/V(1,mp);else  n = max(4*m, 100);  upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 + q;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);      endend  mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = (-1).^(0:(n-1))'.*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:n)', u1(ii));    zu2 = bessely((0:n)', u2(ii));    y(ii) = y(ii)+ coeff'*( ju1(1:n).*zu2(2:(n+1)) + ju1(2:(n+1)).*zu2(1:n) );end  y = y*(-1)^(mp-1)/V(1,mp);endfunction y = MCH(m, z, q)%% Computes the even radial Mathieu function% associated with the Bessel function H% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable positive%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(5*m, 200);    upper = q*ones(n,1);  middle = 4*(0:(n-1))'.^2;  lower = q*ones(n,1);  lower(1) = lower(1) + q;  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sr', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);      endend        mp = (m+2)/2;    ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = (-1).^(0:(n-1))'.*V(1:n,mp);    for ii=1:lz,    ju1 = besselj((0:n)', u1(ii));    I = find(abs(ju1) < 1e-50);    ju1(I) = 0.0;    I = find(isnan(ju1) == 1);    ju1(I) = 0.0;    ju1 = sparse(ju1);    zu2_r = besselj((0:n)', u2(ii));    I = find(abs(zu2_r) < 1e-50);    zu2_r(I) = 0.0;    I = find(isnan(zu2_r) == 1);    zu2_r(I) = 0.0;    zu2_i = bessely((0:n)', u2(ii));    I = find(abs(zu2_i) > 1e+50);    zu2_i(I) = sign(zu2_i(I))*1e+50;    I = find(isinf(zu2_i) == 1);    zu2_i(I) = sign(zu2_i(I))*1e+50;    zu2 = sparse(zu2_r + sqrt(-1)*zu2_i);    y(ii) = y(ii) + coeff'*( ju1(1:n).*zu2(1:n) );end  y = y*(-1)^(m/2)/V(1,mp);else  n = max(5*m, 200);  upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 + q;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);      endend  mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = (-1).^(0:(n-1))'.*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:(n+1))', u1(ii));    I = find(abs(ju1) < 1e-50);    ju1(I) = 0.0;    I = find(isnan(ju1) == 1);    ju1(I) = 0.0;    ju1 = sparse(ju1);    zu2_r = besselj((0:(n+1))', u2(ii));    I = find(abs(zu2_r) < 1e-50);    zu2_r(I) = 0.0;    I = find(isnan(zu2_r) == 1);    zu2_r(I) = 0.0;    zu2_i = bessely((0:(n+1))', u2(ii));    I = find(abs(zu2_i) > 1e+50);    zu2_i(I) = sign(zu2_i(I))*1e+50;    I = find(isinf(zu2_i) == 1);    zu2_i(I) = sign(zu2_i(I))*1e+50;    zu2 = sparse(zu2_r + sqrt(-1)*zu2_i);    y(ii) = y(ii)+ coeff'*( ju1(1:n).*zu2(2:(n+1)) + ju1(2:(n+1)).*zu2(1:n) );end  y = y*(-1)^(mp-1)/V(1,mp);endfunction I = simpson(fun,a,b,npanel,varargin)% simpson    Composite Simpson's rule%% Synopsis:  I = simpson(fun,a,b,npanel)%% Input:     fun    = (string) name of m-file that evaluates f(x)%            a, b   = lower and upper limits of the integral%            npanel = number of panels to use in the integration%                     Total number of nodes = 2*npanel + 1%% Output:    I = approximate value of the integral from a to b of f(x)*dxn = 2*npanel + 1;    %  total number of nodesh = (b-a)/(n-1);     %  stepsizex = a:h:b;           %  divide the intervalf = feval(fun,x);    %  evaluate integrandI = (h/3)*( f(1) + 4*sum(f(2:2:n-1)) + 2*sum(f(3:2:n-2)) + f(n) );%           f(a)         f_even              f_odd         f(b)function y = MCJ(m, z, q)%% Computes the even radial Mathieu function% associated with the Bessel function J% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable positive%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = 100 + 4*m;  upper = q*ones(n,1);  middle = 4*(0:(n-1))'.^2;  lower = q*ones(n,1);  lower(1) = lower(1) + q;  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sr', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);      endend  mp = (m+2)/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = (-1).^(0:(n-1))'.*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:(n-1))', u1(ii));    zu2 = besselj((0:(n-1))', u2(ii));     y(ii) = y(ii) + coeff'*( ju1(1:n).*zu2(1:n) ); end  y = y*(-1)^(m/2)/V(1,mp);else  n = 100 + 4*m;  upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 + q;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);      endend  mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = (-1).^(0:(n-1))'.*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:n)', u1(ii));    zu2 = besselj((0:n)', u2(ii));    y(ii) = y(ii)+ coeff'*( ju1(1:n).*zu2(2:(n+1)) + ju1(2:(n+1)).*zu2(1:n) );end  y = y*(-1)^(mp-1)/V(1,mp);endfunction y = MSJ(m, z, q)%% Computes the odd radial Mathieu function% associated with the Bessel function J% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable belonging to [0, 2pi]%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(4*m, 100);  upper = q*ones(n,1);  middle = 4*(1:n)'.^2;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (2*(1:n)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);      endend  mp = m/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(1:n)').*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:(n+1))', u1(ii));    zu2 = besselj((0:(n+1))', u2(ii));    y(ii) = y(ii) + coeff'*( ju1(1:n).*zu2(3:(n+2)) - ju1(3:(n+2)).*zu2(1:n) );end  y = y*(-1)^(m/2)/V(1,mp);else  n = max(4*m, 100);  upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 - q;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if ((2*(0:(n-1))+1)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);      endend  mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(0:(n-1))').*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:n)', u1(ii));    zu2 = besselj((0:n)', u2(ii));    y(ii) = y(ii)+ coeff'*( ju1(1:n).*zu2(2:(n+1)) - ju1(2:(n+1)).*zu2(1:n) );end  y = y*(-1)^(mp-1)/V(1,mp);endfunction y = MSH(m, z, q)%% Computes the odd radial Mathieu function% associated with the Bessel function H% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable belonging to [0, 2pi]%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(4*m, 100);  upper = q*ones(n,1);  middle = 4*(1:n)'.^2;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (2*(1:n)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);      endend  mp = m/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(1:n)').*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:(n+1))', u1(ii));    zu2 = besselj((0:(n+1))', u2(ii)) + sqrt(-1)*bessely((0:(n+1))', u2(ii));    y(ii) = y(ii) + coeff'*( ju1(1:n).*zu2(3:(n+2)) - ju1(3:(n+2)).*zu2(1:n) );end y = y*(-1)^(m/2)/V(1,mp);else  n = max(4*m, 100);  upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 - q;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);  [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if ((2*(0:(n-1))+1)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);      endend  mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);  u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(0:(n-1))').*V(1:n,mp);  for ii=1:lz,    ju1 = besselj((0:n)', u1(ii));    zu2 = besselj((0:n)', u2(ii)) + sqrt(-1)*bessely((0:n)', u2(ii));    y(ii) = y(ii)+ coeff'*( ju1(1:n).*zu2(2:(n+1)) - ju1(2:(n+1)).*zu2(1:n) );end  y = y*(-1)^(mp-1)/V(1,mp);endfunction y = DMCH(m, z, q)%% Computes the first derivative of the even radial % Mathieu function associated with the Bessel function H% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable positive%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(5*m, 200);    upper = q*ones(n,1);  middle = 4*(0:(n-1))'.^2;  lower = q*ones(n,1);  lower(1) = lower(1) + q;  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sr', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);        end  end        mp = (m+2)/2;    ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = 0.5*(-1).^(1:(n-1))'.*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:n)', u1(ii));    I = find(abs(ju1) < 1e-50);    ju1(I) = 0.0;    I = find(isnan(ju1) == 1);    ju1(I) = 0.0;    ju1 = sparse(ju1);    zu2_r = besselj((0:n)', u2(ii));    I = find(abs(zu2_r) < 1e-50);    zu2_r(I) = 0.0;    I = find(isnan(zu2_r) == 1);       zu2_r(I) = 0.0;    zu2_i = bessely((0:n)', u2(ii));    I = find(abs(zu2_i) > 1e+50);    zu2_i(I) = sign(zu2_i(I))*1e+50;    I = find(isinf(zu2_i) == 1);    zu2_i(I) = sign(zu2_i(I))*1e+50;    zu2 = sparse(zu2_r + sqrt(-1)*zu2_i);    y(ii) = V(1,mp)*( - (-ju1(2))*zu2(1)/ez(ii) + ju1(1)*(-zu2(2))*ez(ii) );    y(ii) = y(ii)+coeff'*( -( ju1(1:(n-1))-ju1(3:(n+1)) ).*zu2(2:n)/ez(ii) ...          + ju1(2:n).*( zu2(1:(n-1))-zu2(3:(n+1)) )*ez(ii));  end  y = y*(-1)^(m/2)*tmp/V(1,mp);  else      n = max(5*m, 200);    upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 + q;  lower = q*ones(n,1);    K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);    for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);        end  end    mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = 0.5*(-1).^(1:(n-1))'.*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:(n+1))', u1(ii));    I = find(abs(ju1) < 1e-50);    ju1(I) = 0.0;    I = find(isnan(ju1) == 1);    ju1(I) = 0.0;    ju1 = sparse(ju1);    zu2_r = besselj((0:(n+1))', u2(ii));    I = find(abs(zu2_r) < 1e-50);    zu2_r(I) = 0.0;    I = find(isnan(zu2_r) == 1);    zu2_r(I) = 0.0;    zu2_i = bessely((0:(n+1))', u2(ii));    I = find(abs(zu2_i) > 1e+50);    zu2_i(I) = sign(zu2_i(I))*1e+50;    I = find(isinf(zu2_i) == 1);    zu2_i(I) = sign(zu2_i(I))*1e+50;    zu2 = sparse(zu2_r + sqrt(-1)*zu2_i);    y(ii) = V(1,mp)*( - (-ju1(2))*zu2(2)/ez(ii) ...                      + ju1(1)*0.5*(zu2(1)-zu2(3))*ez(ii) ...                      - 0.5*(ju1(1)-ju1(3))*zu2(1)/ez(ii) ...                      + ju1(2)*(-zu2(2))*ez(ii) );    y(ii) = y(ii) + coeff'*( ...            - ( ju1(1:(n-1)) - ju1(3:(n+1)) ).*zu2(3:(n+1))/ez(ii) ...            + ju1(2:n).*( zu2(2:n) - zu2(4:(n+2)) ).*ez(ii) ...            - ( ju1(2:n) - ju1(4:(n+2)) ).*zu2(2:n)/ez(ii) ...            + ju1(3:(n+1)).*( zu2(1:(n-1)) - zu2(3:(n+1)) ).*ez(ii) );  end  y = y*(-1)^(mp-1)*tmp/V(1,mp);  endfunction y = DMSH(m, z, q)%% Computes the first derivative of the odd radial% Mathieu function associated with the Bessel function H% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable belonging to [0, 2pi]%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(4*m, 100);    upper = q*ones(n,1);  middle = 4*(1:n)'.^2;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);    for ii=1:(n/2),    if (2*(1:n)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);        end  end    mp = m/2;  ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(2:n)').*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:(n+2))', u1(ii));    zu2 = besselj((0:(n+2))', u2(ii)) + sqrt(-1)*bessely((0:(n+2))', u2(ii));    y(ii) = - V(1,mp)*( -(-ju1(2))*zu2(3)/ez(ii) ...                       + ju1(1)*ez(ii)*0.5*(zu2(2)-zu2(4)) ...                       + 0.5*(ju1(2)-ju1(4))/ez(ii)*zu2(1) ...                       - ju1(3)*(-zu2(2))*ez(ii) );    y(ii) = y(ii) + 0.5*coeff'*( ...                  - ( ju1(1:(n-1)) - ju1(3:(n+1)) )./ez(ii).*zu2(4:(n+2)) ...                  + ju1(2:n).*ez(ii).*( zu2(3:(n+1)) - zu2(5:(n+3)) ) ...                  + ( ju1(3:(n+1)) - ju1(5:(n+3)) )./ez(ii).*zu2(2:n) ...                  - ju1(4:(n+2)).*ez(ii).*( zu2(1:(n-1)) - zu2(3:(n+1)) ) );  end  y = y*(-1)^(m/2)*tmp/V(1,mp);  else      n = max(4*m, 100);    upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 - q;  lower = q*ones(n,1);    K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);    for ii=1:(n/2),    if ((2*(0:(n-1))+1)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);        end  end    mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(1:(n-1))').*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:(n+1))', u1(ii));    zu2 = besselj((0:(n+1))', u2(ii)) + sqrt(-1)*bessely((0:(n+1))', u2(ii));    y(ii) = V(1,mp)*( - (-ju1(2))/ez(ii)*zu2(2) ...                     + ju1(1)*0.5*ez(ii)*(zu2(1) - zu2(3)) ...                     + 0.5*(ju1(1) - ju1(2))/ez(ii)*zu2(1) ...                     - ju1(2)*(-zu2(2))*ez(ii) );    y(ii) = y(ii)+ 0.5*coeff'*( - ( ju1(1:(n-1)) - ju1(3:(n+1)) )/ez(ii).*zu2(3:(n+1)) ...                              + ju1(2:n).*ez(ii).*( zu2(2:n) - zu2(4:(n+2)) ) ...                              + ( ju1(2:n) - ju1(4:(n+2)) )./ez(ii).*zu2(2:n) ...                              - ju1(3:(n+1)).*ez(ii).*( zu2(1:(n-1)) - zu2(3:(n+1)) ) );  end  y = y*(-1)^(mp-1)*tmp/V(1,mp);        endfunction y = DMCJ(m, z, q)%% Computes the first derivative of the even radial % Mathieu function associated with the Bessel function J% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable positive%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(4*m, 100);    upper = q*ones(n,1);  middle = 4*(0:(n-1))'.^2;  lower = q*ones(n,1);  lower(1) = lower(1) + q;  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sr', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);  for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);        end  end        mp = (m+2)/2;    ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = 0.5*(-1).^(1:(n-1))'.*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:n)', u1(ii));    zu2 = besselj((0:n)', u2(ii));    y(ii) = V(1,mp)*( - (-ju1(2))*zu2(1)/ez(ii) + ju1(1)*(-zu2(2))*ez(ii) );    y(ii) = y(ii)+coeff'*( -( ju1(1:(n-1))-ju1(3:(n+1)) ).*zu2(2:n)/ez(ii) ...          + ju1(2:n).*( zu2(1:(n-1))-zu2(3:(n+1)) )*ez(ii));  end  y = y*(-1)^(m/2)*tmp/V(1,mp);  else      n = max(4*m, 100);    upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 + q;  lower = q*ones(n,1);    K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);    for ii=1:(n/2),    if (V(:,ii)'*ones(n,1) < 0)      V(:, ii) = -V(:,ii);        end  end    mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = 0.5*(-1).^(1:(n-1))'.*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:(n+1))', u1(ii));    zu2 = besselj((0:(n+1))', u2(ii));    y(ii) = V(1,mp)*( - (-ju1(2))*zu2(2)/ez(ii) ...                      + ju1(1)*0.5*(zu2(1)-zu2(3))*ez(ii) ...                      - 0.5*(ju1(1)-ju1(3))*zu2(1)/ez(ii) ...                      + ju1(2)*(-zu2(2))*ez(ii) );    y(ii) = y(ii) + coeff'*( ...            - ( ju1(1:(n-1)) - ju1(3:(n+1)) ).*zu2(3:(n+1))/ez(ii) ...            + ju1(2:n).*( zu2(2:n) - zu2(4:(n+2)) ).*ez(ii) ...            - ( ju1(2:n) - ju1(4:(n+2)) ).*zu2(2:n)/ez(ii) ...            + ju1(3:(n+1)).*( zu2(1:(n-1)) - zu2(3:(n+1)) ).*ez(ii) );  end  y = y*(-1)^(mp-1)*tmp/V(1,mp);  endfunction y = DMSJ(m, z, q)%% Computes the first derivative of the odd radial% Mathieu function associated with the Bessel function J% following the notations and normalization% of Abramowitz & Stegun (Chapter 20).%% m = Order of the function (integer)%% z = Variable belonging to [0, 2pi]%     Allows vector input%% q = Real parameter%% y = Value of the function%     Returns vector when z is a vector%% UH - 04/03%lz = length(z);y = zeros(lz, 1);if (rem(m, 2) ==0)   n = max(4*m, 100);    upper = q*ones(n,1);  middle = 4*(1:n)'.^2;  lower = q*ones(n,1);  K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);    for ii=1:(n/2),    if (2*(1:n)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);        end  end    mp = m/2;  ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(2:n)').*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:(n+2))', u1(ii));    zu2 = besselj((0:(n+2))', u2(ii));    y(ii) = - V(1,mp)*( -(-ju1(2))*zu2(3)/ez(ii) ...                       + ju1(1)*ez(ii)*0.5*(zu2(2)-zu2(4)) ...                       + 0.5*(ju1(2)-ju1(4))/ez(ii)*zu2(1) ...                       - ju1(3)*(-zu2(2))*ez(ii) );    y(ii) = y(ii) + 0.5*coeff'*( ...                  - ( ju1(1:(n-1)) - ju1(3:(n+1)) )./ez(ii).*zu2(4:(n+2)) ...                  + ju1(2:n).*ez(ii).*( zu2(3:(n+1)) - zu2(5:(n+3)) ) ...                  + ( ju1(3:(n+1)) - ju1(5:(n+3)) )./ez(ii).*zu2(2:n) ...                  - ju1(4:(n+2)).*ez(ii).*( zu2(1:(n-1)) - zu2(3:(n+1)) ) );  end  y = y*(-1)^(m/2)*tmp/V(1,mp);  else      n = max(4*m, 100);    upper = q*ones(n,1);  middle = (2*(0:(n-1))+1)'.^2;  middle(1) = 1 - q;  lower = q*ones(n,1);    K = spdiags([lower middle upper], -1:1, n, n);  OPTS.disp = 0;  [V, D] = eigs(K, n/2, 'sa', OPTS);    [D, I] = sort(diag(D));  V = V(:, I);    for ii=1:(n/2),    if ((2*(0:(n-1))+1)*V(:,ii) < 0)      V(:, ii) = -V(:,ii);        end  end    mp = (m+1)/2;  ez = exp(z);  tmp = sqrt(q);    u1 = tmp./ez;  u2 = tmp.*ez;  coeff = ((-1).^(1:(n-1))').*V(2:n,mp);    for ii=1:lz,    ju1 = besselj((0:(n+1))', u1(ii));    zu2 = besselj((0:(n+1))', u2(ii));    y(ii) = V(1,mp)*( - (-ju1(2))/ez(ii)*zu2(2) ...                     + ju1(1)*0.5*ez(ii)*(zu2(1) - zu2(3)) ...                     + 0.5*(ju1(1) - ju1(2))/ez(ii)*zu2(1) ...                     - ju1(2)*(-zu2(2))*ez(ii) );    y(ii) = y(ii)+ 0.5*coeff'*( - ( ju1(1:(n-1)) - ju1(3:(n+1)) )/ez(ii).*zu2(3:(n+1)) ...                              + ju1(2:n).*ez(ii).*( zu2(2:n) - zu2(4:(n+2)) ) ...                              + ( ju1(2:n) - ju1(4:(n+2)) )./ez(ii).*zu2(2:n) ...                              - ju1(3:(n+1)).*ez(ii).*( zu2(1:(n-1)) - zu2(3:(n+1)) ) );  end  y = y*(-1)^(mp-1)*tmp/V(1,mp);        end